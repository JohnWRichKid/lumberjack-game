// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract LumberjackGame {
    // Events for tracking
    event Chop(address indexed player, address indexed burner, uint256 chopNumber, uint256 timestamp);
    event GameStarted(address indexed player, address indexed burner, uint256 timestamp);
    event GameEnded(address indexed player, address indexed burner, uint256 finalScore, uint256 timestamp);
    event TournamentJoined(uint256 indexed tournamentId, address indexed player, uint256 entryFee);
    event ScoreSubmitted(uint256 indexed tournamentId, address indexed player, uint256 score);
    event TournamentAdvanced(uint256 indexed tournamentId, address[] winners, uint256 prizePerWinner);

    // High scores
    mapping(address => uint256) public highScores;
    
    // Total chops ever
    uint256 public totalChops;

    // Leaderboard entry
    struct LeaderboardEntry {
        address player;
        uint256 score;
        uint256 timestamp;
    }
    
    LeaderboardEntry[] public leaderboard;

    // Tournament constants
    uint256 public constant SIGNUP_DURATION = 5 minutes;
    uint256 public constant PLAY_DURATION = 5 minutes;
    uint256 public constant SCORE_SUBMIT_GRACE_PERIOD = 5 seconds;
    uint256 public constant ENTRY_FEE = 10 ether;

    // Tournament state
    uint256 public currentTournamentId;
    
    struct Tournament {
        uint256 signupEndTime;
        uint256 playEndTime;
        uint256 prizePool;
        uint256 playerCount;
        uint256 highScore;
        address[] players;
        mapping(address => bool) registered;
        mapping(address => uint256) scores;
        uint8 phase; // 0 = signup, 1 = play, 2 = ended
        bool finalized;
    }
    
    mapping(uint256 => Tournament) public tournaments;
    
    // Last tournament results
    struct LastResult {
        uint256 tournamentId;
        address[] winners;
        uint256 highScore;
        uint256 prizePerWinner;
        uint256 playerCount;
    }
    
    LastResult public lastTournamentResult;

    constructor() {
        currentTournamentId = 1;
        Tournament storage t = tournaments[currentTournamentId];
        t.signupEndTime = block.timestamp + SIGNUP_DURATION;
        t.playEndTime = t.signupEndTime + PLAY_DURATION;
        t.phase = 0;
    }

    // Start a game session
    function startGame(address mainWallet) external {
        emit GameStarted(mainWallet, msg.sender, block.timestamp);
    }

    // Record a single chop (called by burner wallet)
    function chop(address mainWallet, uint256 chopNumber) external {
        totalChops++;
        emit Chop(mainWallet, msg.sender, chopNumber, block.timestamp);
    }

    // End game and record final score
    function endGame(address mainWallet, uint256 finalScore) external {
        emit GameEnded(mainWallet, msg.sender, finalScore, block.timestamp);
        
        // Update high score if better
        if (finalScore > highScores[mainWallet]) {
            highScores[mainWallet] = finalScore;
            
            // Update leaderboard
            bool found = false;
            for (uint i = 0; i < leaderboard.length; i++) {
                if (leaderboard[i].player == mainWallet) {
                    leaderboard[i].score = finalScore;
                    leaderboard[i].timestamp = block.timestamp;
                    found = true;
                    break;
                }
            }
            if (!found) {
                leaderboard.push(LeaderboardEntry(mainWallet, finalScore, block.timestamp));
            }
        }
    }

    // Join current tournament
    function joinTournament() external payable {
        Tournament storage t = tournaments[currentTournamentId];
        require(t.phase == 0, "Signup phase ended");
        require(block.timestamp < t.signupEndTime, "Signup time expired");
        require(msg.value == ENTRY_FEE, "Wrong entry fee");
        require(!t.registered[msg.sender], "Already registered");
        
        t.registered[msg.sender] = true;
        t.players.push(msg.sender);
        t.playerCount++;
        t.prizePool += msg.value;
        
        emit TournamentJoined(currentTournamentId, msg.sender, msg.value);
    }

    // Submit score during play phase or grace period after
    function submitScore(uint256 score) external {
        Tournament storage t = tournaments[currentTournamentId];
        require(t.phase == 1, "Not in play phase");
        require(block.timestamp < t.playEndTime + SCORE_SUBMIT_GRACE_PERIOD, "Submission window closed");
        require(t.registered[msg.sender], "Not registered");
        
        if (score > t.scores[msg.sender]) {
            t.scores[msg.sender] = score;
            if (score > t.highScore) {
                t.highScore = score;
            }
            emit ScoreSubmitted(currentTournamentId, msg.sender, score);
        }
    }

    // Advance tournament (callable by anyone when time expires)
    function advanceTournament() external {
        Tournament storage t = tournaments[currentTournamentId];
        
        if (t.phase == 0 && block.timestamp >= t.signupEndTime) {
            t.phase = 1;
        } else if (t.phase == 1 && block.timestamp >= t.playEndTime + SCORE_SUBMIT_GRACE_PERIOD) {
            t.phase = 2;
            _finalizeTournament();
        } else if (t.phase == 2 && t.finalized) {
            _startNewTournament();
        }
    }

    function _finalizeTournament() private {
        Tournament storage t = tournaments[currentTournamentId];
        require(!t.finalized, "Already finalized");
        
        address[] memory winners = new address[](t.playerCount);
        uint256 winnerCount = 0;
        
        // Find all players with high score
        if (t.highScore > 0) {
            for (uint i = 0; i < t.players.length; i++) {
                if (t.scores[t.players[i]] == t.highScore) {
                    winners[winnerCount] = t.players[i];
                    winnerCount++;
                }
            }
        }
        
        uint256 prizePerWinner = 0;
        
        // Distribute prizes
        if (t.playerCount == 0) {
            // No players - nothing to do
        } else if (t.playerCount == 1) {
            // Solo player - refund
            (bool success, ) = payable(t.players[0]).call{value: t.prizePool}("");
            require(success, "Refund failed");
        } else if (winnerCount == 0 || t.highScore == 0) {
            // No scores - refund all
            uint256 refund = t.prizePool / t.playerCount;
            for (uint i = 0; i < t.players.length; i++) {
                (bool success, ) = payable(t.players[i]).call{value: refund}("");
                require(success, "Refund failed");
            }
        } else {
            // Normal win - split among winners
            prizePerWinner = t.prizePool / winnerCount;
            for (uint i = 0; i < winnerCount; i++) {
                (bool success, ) = payable(winners[i]).call{value: prizePerWinner}("");
                require(success, "Prize transfer failed");
            }
        }
        
        // Save results
        lastTournamentResult.tournamentId = currentTournamentId;
        lastTournamentResult.highScore = t.highScore;
        lastTournamentResult.prizePerWinner = prizePerWinner;
        lastTournamentResult.playerCount = t.playerCount;
        delete lastTournamentResult.winners;
        for (uint i = 0; i < winnerCount; i++) {
            lastTournamentResult.winners.push(winners[i]);
        }
        
        t.finalized = true;
        
        emit TournamentAdvanced(currentTournamentId, lastTournamentResult.winners, prizePerWinner);
    }

    function _startNewTournament() private {
        currentTournamentId++;
        Tournament storage t = tournaments[currentTournamentId];
        t.signupEndTime = block.timestamp + SIGNUP_DURATION;
        t.playEndTime = t.signupEndTime + PLAY_DURATION;
        t.phase = 0;
    }

    // View functions
    function getTournamentInfo() external view returns (
        uint256 tournamentId,
        uint256 signupEndTime,
        uint256 playEndTime,
        uint256 prizePool,
        uint256 playerCount,
        uint256 highScore,
        uint8 phase,
        bool finalized
    ) {
        Tournament storage t = tournaments[currentTournamentId];
        return (
            currentTournamentId,
            t.signupEndTime,
            t.playEndTime,
            t.prizePool,
            t.playerCount,
            t.highScore,
            t.phase,
            t.finalized
        );
    }

    function isPlayerRegistered(uint256 tournamentId, address player) external view returns (bool) {
        return tournaments[tournamentId].registered[player];
    }

    function getPlayerScore(uint256 tournamentId, address player) external view returns (uint256) {
        return tournaments[tournamentId].scores[player];
    }

    function getLastTournamentResult() external view returns (
        uint256 tournamentId,
        address[] memory winners,
        uint256 highScore,
        uint256 prizePerWinner,
        uint256 playerCount
    ) {
        return (
            lastTournamentResult.tournamentId,
            lastTournamentResult.winners,
            lastTournamentResult.highScore,
            lastTournamentResult.prizePerWinner,
            lastTournamentResult.playerCount
        );
    }

    // Get player's high score
    function getHighScore(address player) external view returns (uint256) {
        return highScores[player];
    }

    // Get leaderboard length
    function getLeaderboardLength() external view returns (uint256) {
        return leaderboard.length;
    }

    // Get leaderboard entry
    function getLeaderboardEntry(uint256 index) external view returns (address, uint256, uint256) {
        require(index < leaderboard.length, "Index out of bounds");
        LeaderboardEntry memory entry = leaderboard[index];
        return (entry.player, entry.score, entry.timestamp);
    }
}
